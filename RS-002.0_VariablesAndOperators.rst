Constants, Variables, Datatypes & Operators in Rust 
####################################################

**objectives**

1. Explore the *Constant item* in Rust 
#. Learn how we can separate large number for easy to read code 
#. Explore different scalar data types
#. Explore the precision of different floating point numbers

.. raw:: html

   <iframe width="560" height="315" 
   src="https://www.youtube.com/embed/ygL_xcavzQ4?si=r5UQBEpmHd9yR7LA&amp;start=749&end=1381" 
   title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; 
   clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
   referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
   </iframe>

**Pre-reqs**

1. For this tutorial I created a new project with ``cargo new tut-002_var-datatype-ops``

Constant [2]_
***************

Another thing about variable in rust, is that we can declare them to be constant 
using the ``const`` keyword.

* the popular nomenclature for constant variable is to use all upper case for 
  the constant variable name.

  * **syntax**: ``const`` <CONST_NAME> ``:`` <type> ``=`` <value>

  * ex: ``const ONE_MIL: u32 = 1_000_000;``
    
    * in rust, you can separate big values using an underscore ``_`` as shown above.
    * constant must be explicitly typed. Rust is a statically typed language. The 
      type of the variable is always known at compiled time. Some type must be 
      explicitly typed during declaration, other are implicitly typed by the compiler.


1. Let start type the following code 
   
   :base tag: ``RS-002.0_v0.0.1``

   .. code-block:: diff 
      :caption: tut-002_var-datatype-ops/src/main.rs

      --- a/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
      +++ b/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
      @@ -1,3 +1,14 @@
      +// constant variables demo code:
      +
       fn main() {
      -    println!("Hello, world!");
      +    const ONE_MIL: u32 = 1_000_000;
      +    const PI : f32 = 3.141592;
      +    let age = "47"; // a string, implicitly typed. defined with double quotes
      +    let mut age: u32 = age.trim().parse() // LEGAL in rust to re-use the same variable name. Shadowing
      +        .expect("Age wasn't assigned a number"); 
      +
      +    // now that the age is a u32, we can do operation.
      +    age = age + 1; // increment by 1.
      +
      +    println!("I'm {} and I want ${} so I can buy some {}", age, ONE_MIL, PI);
       }

.. card:: Code explanation

   * we ``age`` as a string and one as a unsigned 32-bit (u32). 
     
     * This is perfectly okay in rust. You can define variables with the same 
       name but with different data types. This is called **shadowing**. The second
       declaration using ``let`` is what the compiler will see.

       .. seealso:: * `Variable and Mutability | Constant | Shadowing (rust prog lang book)`_
     
     * we use ``.trim()`` on the string to get rid of any whitespace, then ``.parse()``
       to parse on it, which will return a unsigned 32 bit integer in that case.


.. card:: Testing 

   :tag: ``RS-002.0_v0.0.2``

   1. run the code and observe the terminal output 

   .. code-block:: console
      :emphasize-lines: 6

       *  Executing task: C:\Users\ricky\.cargo\bin\cargo.EXE run --package tut-002_var-datatype-ops --bin tut-002_var-datatype-ops 

         Compiling tut-002_var-datatype-ops v0.1.0 (Wiki_RustTutorialDerek\_resources\Examples\tut-002_var-datatype-ops)
          Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
           Running `target\debug\tut-002_var-datatype-ops.exe`
      I'm 48 and I want $1000000 so I can buy some 3.141592

.. seealso:: Learn more about Constant items:
   
   * `Const Keyword (std lib book)`_ 
   * `Variable and Mutability | Constant | Shadowing (rust prog lang book)`_
   * `const keyword (rust reference)`_

Data types [1]_ [3]_ [4]_ [5]_
*********************************

.. note:: to self: Even though Derek, the instructor, did not expand on some topic,
   I research the topic and put some better notes and reading links so I can really 
   frame the lessons correctly.

Rust is statically typed i.e the data type has to be known at compile-time. The types 
must be defined.

* These types are going to be often generated by the compiler for you. 
  
  * **implicit typed annotation** (inferred by the compiler based on value assigned) 

* or you can go and define them explicitly in certain situations
  
  * **explicit typed annotation**

Data types in rust can be categorized as followed:

1. **Primitive data types** (built-in data types)
   
   I. **Scalar types**: 
      
      * only 4: integers, float, booleans, characters
        
        * although some have variants. ex: i8, i32, u32, f32, etc...

   #. **Compound Types**
   
      * only 2: tuples and arrays.
   
   #. etc...
   
#. **Custom types** 
      
   * Examples 
      
     - Struct 
     - Enums
   
.. note:: There are more datatypes and information on them. You can 
   further read using these links:

   .. seealso:: * `Primitive types (Crate std)`_

      * `Data Types (Rust prog lang book)`_
      * `Type Layout (Rust Reference book)`_
         
        * this will teach you about size and alignment and some platform 
          (64-bit arch, 32-bit arch) specific information.

Scalar Types 
=============

Integers 
---------

* **Unsigned integer**: ``u8``, ``u16``, ``u32``, ``u64``, ``u128``, ``usize``
  
  * they can be used to represent positive integers only. 

    * ``usize`` can be used to represent any **unsigned** integer types really and is preferred 
      to use when indexing some sort of collection (like vectors, array, tuples (more on that later))
    
* **signed integer**: ``i8``, ``i16``, ``i32``, ``i64``, ``i128``, ``isize``
  
  * can represent negative integers also.
    
    * ``isize`` can be used to represent any **signed** integer type really and is preferred 
      to use when indexing some sort of collection (like vectors, array, tuples (more on that later))

  * the value is stored using 2's complement form.


+--------+----------+--------------------+
| Signed | Unsigned | size_of::<Type>()  |
+========+==========+====================+
| i8     | u8       | 1 byte (8-bit)     |
+--------+----------+--------------------+
| i16    | u16      | 2 bytes (16-bits)  |
+--------+----------+--------------------+
| i32    | u32      | 4 bytes (32-bits)  |
+--------+----------+--------------------+
| i64    | u64      | 8 bytes (64-bit)   |
+--------+----------+--------------------+
| i128   | u128     | 16 bytes (128-bit) |
+--------+----------+--------------------+
| isize  | usize    | platform-specific  |
+--------+----------+--------------------+

.. note:: Each signed variant can store numbers from :math:`-(2^{n - 1})` to 
   :math:`2^{n - 1} - 1` inclusive, where ``n`` is the number of bits that 
   variant uses. 
   
   * So an ``i8`` can store numbers from :math:`-(2^7)` to :math:`2^7 - 1`,
     
     * which equals -128 to 127

.. compound:: [5]_
   :class: light-gray-bg

   * The **alignment** of a value 
     
     * specifies what addresses are valid to store the value at. 
     * is measured in bytes, 
     * and must be at least 1, and always a power of 2. 
   
   * A value of alignment ``n`` must only be stored at an address that is a 
     multiple of ``n``. 
     
     * For example, 
       
       1. a value with an alignment of **2** must be stored at an **even address**, 
       2. while a value with an alignment of **1** can be stored at **any address**. 
   
   * The alignment of a value can be checked with the ``align_of_val`` function.
   * The alignment of primitives is platform-specific
     
     * In most cases, their alignment is equal to their size, but it may be less. 
     * In particular, ``i128`` and ``u128`` are often aligned to 4 or 8 bytes 
       even though their size is **16**, 
     * and on many 32-bit platforms, ``i64``, ``u64``, and ``f64`` are only 
       aligned to 4 bytes, not 8.
   
   
   * The **size** of a value 
     
     * is the offset in bytes between successive elements in an array with that 
       item type including alignment padding.
     
     * The size of a value is always a multiple of its alignment. 
   
       .. note:: Note that some types are zero-sized; 0 is considered a multiple of 
          any alignment (for example, on some platforms, the type ``[u16; 0]`` has 
          size 0 and alignment 2). 
     
     * The size of a value can be checked with the ``size_of_val function``.

   .. important:: 
      
      * Types where all values have the same size and alignment, and both are known 
        at compile time, 
        
        * implement the `Sized`_ trait 
        * and can be checked with the ``size_of`` and ``align_of`` functions. 
      
      * Types that are not `Sized`_   are known as `dynamically sized types`_. 
      
      .. note:: Since all values of a Sized type share the same size and alignment, 
         we refer to those shared values as the size of the type and the alignment 
         of the type respectively.
   
   * ``usize`` and ``isize`` 
   
     * have a size big enough to contain every address on the target platform. 
     * For example, 
     
       * on a 32 bit target, this is 4 bytes, 
       * and on a 64 bit target, this is 8 bytes

Float 
------

* to represent floating-point number (number with decimal)
* have limited precision.
* Rust only support 2 primitive types for floating-point number: [4]_
  
  1. ``f32`` - 32 bits in size 
  #. ``f64`` - 64 bits in size (default type)

  .. note:: * all floating-point are signed 
     
     * Floating-point numbers are represented according to the IEEE-754 standard.

Boolean 
--------

* keyword ``bool``
* represent logical value: ``true`` or ``false``

Char 
----

``char``

* use to store singe character (letters, digits, symbols (emojis), etc)
* the char  value is single quoted ``'A'``
* Rust use 4 bytes `Unicode Scalar Values`_ for character encoding.
  
  * Unicode Scalar Values range from ``U+0000`` to ``U+D7FF`` 
    and ``U+E000`` to ``U+10FFFF`` inclusive.

Exercise 
**********

1. Make the following changes to tut-002_var-datatype-ops/src/main.rs 
   
   :base tag: ``RS-002.0_v0.0.2``

   .. code-block:: diff 
      :caption: src/main.rs 

      --- a/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
      +++ b/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
      @@ -1,7 +1,9 @@
       // constant variables demo code:

       fn main() {
      -    const ONE_MIL: u32 = 1_000_000;
      +    println!("-------------------------------------------------------------------");
      +
      +    const ONE_MIL: u32 = 1_000_000; // need explicit type annotation
           const PI : f32 = 3.141592;
           let age = "47"; // a string, implicitly typed. defined with double quotes
           let mut age: u32 = age.trim().parse() // LEGAL in rust to re-use the same variable name. Shadowing
      @@ -11,4 +13,41 @@ fn main() {
           age = age + 1; // increment by 1.

           println!("I'm {} and I want ${} so I can buy some {}", age, ONE_MIL, PI);
      +
      +    println!("-------------------------------------------------------------------");
      +    
      +    // Integer Datatypes and their maximum value:
      +    println!("Max i8: {}", i8::MAX);
      +    println!("Max u8: {}", u8::MAX);
      +    println!("Max i16: {}", i16::MAX);
      +    println!("Max u16: {}", u16::MAX);
      +    println!("Max i32: {}", i32::MAX);
      +    println!("Max u32: {}", u32::MAX);
      +    println!("Max i64: {}", i64::MAX);
      +    println!("Max u64: {}", u64::MAX);
      +    println!("Max i128: {}", i128::MAX);
      +    println!("Max u128: {}", u128::MAX);
      +    println!("Max isize: {}", isize::MAX);
      +    println!("Max usize: {}", usize::MAX);
      +
      +    // Some float datatype and their max
      +    println!("-------------------------------------------------------------------");
      +    println!("Max f32: {}", f32::MAX);
      +    println!("Max f64: {}", f64::MAX);
      +    println!("-------------------------------------------------------------------");
      +
      +    // Booleans can have for value: true or false 
      +    let _unused_bool_as_place_holder = true; // start with _ so compiler ignore
      +    let _another_bool: bool = false; // explicit type annotation 
      +    
      +    
      +    // characters are defined using single quote ''
      +    let _my_grade = 'A'; // implicitly infer by compiler to be char type
      +    let _min_grade: char = 'F'; // with explicit type annotation
      +    let mut unassigned_char: char; // var definition, need explicit type
      +    unassigned_char = '🫂'; // character is 4 bytes in Rust, encoded in Unicode Scalar Value.
      +    println!("people hugging emoji: {}", unassigned_char);
      +    unassigned_char = '🍎';
      +    println!("red apple emoji: {}", unassigned_char);
      +    
       }

#. Run the code to test 
   
   .. code-block:: console 
      :caption: example of output 

      Wiki_RustTutorialDerek/_resources/Examples/tut-002_var-datatype-ops (main)
      $ cargo run -p tut-002_var-datatype-ops
         Compiling tut-002_var-datatype-ops v0.1.0 (tut-002_var-datatype-ops)
          Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.79s
           Running `target\debug\tut-002_var-datatype-ops.exe`
      -------------------------------------------------------------------
      I'm 48 and I want $1000000 so I can buy some 3.141592
      -------------------------------------------------------------------
      Max i8: 127
      Max u8: 255
      Max i16: 32767
      Max u16: 65535
      Max i32: 2147483647
      Max u32: 4294967295
      Max i64: 9223372036854775807
      Max u64: 18446744073709551615
      Max i128: 170141183460469231731687303715884105727
      Max u128: 340282366920938463463374607431768211455
      Max isize: 9223372036854775807
      Max usize: 18446744073709551615
      -------------------------------------------------------------------
      Max f32: 340282350000000000000000000000000000000
      Max f64: 17976931348623157000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      0000000000000000000000
      -------------------------------------------------------------------
      people hugging emoji: 🫂
      red apple emoji: 🍎

#. Commit the changes 
   
   :tag: RS-002.0_v0.0.3

Mathematical Operators in Rust 
*******************************

Rust support the following math operator 

* ``*`` : multiplication
* ``/`` : division
* ``+`` : addition 
* ``-`` : subtraction
* ``%`` : modulo operator - return the remainder of a division.

.. card:: Code Exercise 

   1. Add additional code 

      .. code-block:: diff 
         :caption: src/main.c

         --- a/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
         +++ b/_resources/Examples/tut-002_var-datatype-ops/src/main.rs
         @@ -49,5 +49,34 @@ fn main() {
              println!("people hugging emoji: {}", unassigned_char);
              unassigned_char = '🍎';
              println!("red apple emoji: {}", unassigned_char);
         +    println!("-------------------------------------------------------------------\n\n");
         +
         +    // operators 
         +    println!("Float precision testing");
         +    // f32 has 6 digits of precision
         +    let num_1: f32 = 1.111_111_111_111_111;
         +    println!("  1.111_111_111_111_111");
         +    println!("+ 0.111_111_111_111_111");
         +    println!("-------------------------");
         +
         +    println!("f32 : {}", num_1 + 0.111_111_111_111_111);
         +
         +    // f64 has 14 digits of precision
         +    let num_2: f64 = 1.111111111111111;
         +    println!("f64 : {}", num_2 + 0.111111111111111);
         +    println!("-------------------------------------------------------------------");
         +    // Basic math operators
         +    let num_3: u32 = 5;
         +    let num_4: u32 = 4;
         +    println!("5 + 4 = {}", num_3 + num_4);
         +    println!("5 - 4 = {}", num_3 - num_4);
         +    println!("5 * 4 = {}", num_3 * num_4);
         +    println!("5 / 4 = {}", num_3 / num_4);
         +    println!("5 % 4 = {}", num_3 % num_4); // Remainder

         +    let mut num_5 = 6;
         +    println!("num_5 = {}", num_5); 
         +    num_5 += 1; // num_5 = num_5 + 1
         +    println!("num_5 +=1 = {}", num_5); 
         +
          }

   .. seealso:: more operators and their context for use case can be 
      found in 

      * `Operators & Symbols (Rust prog lang book)`_

Summary 
********

Final code 

.. literalinclude:: ./_resources/Examples/tut-002_var-datatype-ops/src/main.rs
   :language: Rust
   :caption: src/main.rs

.. card:: Testing 

   1. Run the code 
   
   .. code-block:: console 
      :caption: example of application 

      Examples/tut-002_var-datatype-ops (main)
      $ cargo run -p tut-002_var-datatype-ops
          Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s
           Running `target\debug\tut-002_var-datatype-ops.exe`
      -------------------------------------------------------------------
      I'm 48 and I want $1000000 so I can buy some 3.141592
      -------------------------------------------------------------------
      Max i8: 127
      Max u8: 255
      Max i16: 32767
      Max u16: 65535
      Max i32: 2147483647
      Max u32: 4294967295
      Max i64: 9223372036854775807
      Max u64: 18446744073709551615
      Max i128: 170141183460469231731687303715884105727
      Max u128: 340282366920938463463374607431768211455
      Max isize: 9223372036854775807
      Max usize: 18446744073709551615
      -------------------------------------------------------------------
      Max f32: 340282350000000000000000000000000000000
      Max f64: 17976931348623157000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      00000000000000000000000000000000000000000000000000000000000000000000000000
      0000000000000000000000      
      -------------------------------------------------------------------
      people hugging emoji: 🫂
      red apple emoji: 🍎
      -------------------------------------------------------------------


      Float precision testing
        1.111_111_111_111_111
      + 0.111_111_111_111_111
      -------------------------
      f32 : 1.2222223
      f64 : 1.2222222222222219
      -------------------------------------------------------------------
      5 + 4 = 9
      5 - 4 = 1
      5 * 4 = 20
      5 / 4 = 1
      5 % 4 = 1
      num_5 = 6
      num_5 +=1 = 7

From this exercise:

* You can see ``f32`` has 6 digits of precision in the decimal part
* ``f64`` has 14 digits of precision.

References 
************

.. [1] `Rust Tutorial Full Course (video)`_
.. [2] `Variable and Mutability | Constant | Shadowing (rust prog lang book)`_
.. [3] `Primitive types (Crate std)`_
.. [4] `Data Types (Rust prog lang book)`_
.. [5] `Type Layout (Rust Reference book)`_


.. include:: ../../relevant_urls.rst
.. include:: ./relevant_urls.rst